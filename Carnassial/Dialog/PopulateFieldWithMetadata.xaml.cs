using Carnassial.Data;
using Carnassial.Database;
using Carnassial.Util;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Controls;

namespace Carnassial.Dialog
{
    /// <summary>
    /// This dialog displays a list of available data fields (currently the note, date and time fields), and 
    /// a list of metadata found in the current image. It asks the user to select one from each.
    /// The user can then populate the selected data field with the corresponding metadata value from that image for all images.
    /// </summary>
    public partial class PopulateFieldWithMetadata : Window
    {
        private bool clearIfNoMetadata;
        private FileDatabase database;
        private string dataFieldLabel;
        private bool dataFieldSelected;
        private Dictionary<string, string> dataLabelByLabel;
        private string filePath;
        private string metadataFieldName;
        private bool metadataFieldSelected;

        public PopulateFieldWithMetadata(FileDatabase database, string filePath, Window owner)
        {
            this.InitializeComponent();
            this.Owner = owner;

            this.clearIfNoMetadata = false;
            this.database = database;
            this.dataFieldLabel = String.Empty;
            this.dataFieldSelected = false;
            this.dataLabelByLabel = new Dictionary<string, string>();
            this.filePath = filePath;
            this.metadataFieldName = String.Empty;
            this.metadataFieldSelected = false;
        }

        // After the interface is loaded, 
        // - Load the Exif data into the data grid
        // - Load the names of the note controls into the listbox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            Utilities.SetDefaultDialogPosition(this);
            Utilities.TryFitWindowInWorkingArea(this);

            this.lblImageName.Content = Path.GetFileName(this.filePath);
            this.dataGrid.ItemsSource = Utilities.LoadMetadata(this.filePath);

            foreach (ControlRow control in this.database.Controls)
            {
                if (control.Type == Constant.DatabaseColumn.DateTime ||
                    control.Type == Constant.Control.Note)
                {
                    this.dataLabelByLabel.Add(control.Label, control.DataLabel);
                    this.DataFields.Items.Add(control.Label);
                }
            }
        }

        // Label the column headers
        private void Datagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.dataGrid.Columns[0].Header = "Metadata Name";
            this.dataGrid.Columns[1].Header = "Example Value";
            this.dataGrid.SortByFirstColumnAscending();
        }

        // The user has selected a row. Get the metadata from that row, and make it the selected metadata.
        private void Datagrid_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        {
            IList<DataGridCellInfo> selectedcells = e.AddedCells;

            // Make sure there are actually some selected cells
            if (selectedcells == null || selectedcells.Count == 0)
            {
                return;
            }

            // should only have a single selected cell, so just grab the first one
            DataGridCellInfo di = selectedcells[0];

            // the selected item is the entire row, where the format returned is [MetadataName, MetadataValue] 
            String[] s = di.Item.ToString().Split(',');  // Get the "[MetadataName" portion before the ','
            this.metadataFieldName = s[0].Substring(1);  // Remove the leading '['
            this.Metadata.Content = this.metadataFieldName;

            this.metadataFieldSelected = true;
            this.PopulateButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        }

        private void NoteFieldsListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.DataFields.SelectedItem != null)
            {
                this.DataField.Content = this.DataFields.SelectedItem as string;
                this.dataFieldLabel = this.DataFields.SelectedItem as string;
                this.dataFieldSelected = true;
            }

            this.PopulateButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        }

        // populate the database with the metadata for the selected field
        private void PopulateField()
        {
            // key/value pairs that will be bound to the datagrid feedback so they appear during background worker progress updates
            ObservableCollection<KeyValuePair<string, string>> keyValueList = new ObservableCollection<KeyValuePair<string, string>>();
            this.FeedbackGrid.ItemsSource = keyValueList;

            // update UI to show the feedback datagrid
            this.PopulatingMessage.Text = "Populating the data field '" + this.dataFieldLabel + "' from each file's '" + this.metadataFieldName + "' metadata ";
            this.PopulateButton.Visibility = Visibility.Collapsed;
            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed;
            this.PrimaryPanel.Visibility = Visibility.Collapsed;
            this.DataFields.Visibility = Visibility.Collapsed;
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;

            BackgroundWorker backgroundWorker = new BackgroundWorker() { WorkerReportsProgress = true };
            backgroundWorker.DoWork += (ow, ea) =>
            {
                // for each file try to get the chosen metadata value.
                string dataLabelToUpdate = this.dataLabelByLabel[this.dataFieldLabel];
                bool dateTimeUpdate = dataLabelToUpdate == Constant.DatabaseColumn.DateTime;
                List<ImageRow> filesForDateTimeUpdate = new List<ImageRow>();
                FileTuplesWithID filesToUpdate = new FileTuplesWithID(dataLabelToUpdate);

                TimeZoneInfo imageSetTimeZone = this.database.ImageSet.GetTimeZone();
                for (int fileIndex = 0; fileIndex < database.CurrentlySelectedFileCount; ++fileIndex)
                {
                    ImageRow file = database.Files[fileIndex];
                    Dictionary<string, string> metadata = Utilities.LoadMetadata(file.GetFilePath(database.FolderPath));
                    if (metadata.ContainsKey(this.metadataFieldName) == false)
                    {
                        if (this.clearIfNoMetadata)
                        {
                            if (dateTimeUpdate)
                            {
                                file.SetDateTimeOffsetFromFileInfo(this.database.FolderPath, imageSetTimeZone);
                                filesForDateTimeUpdate.Add(file);
                                backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, "No metadata found - date/time reread from file"));
                            }
                            else
                            {
                                filesToUpdate.Add(file.ID, String.Empty);
                                backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, "No metadata found - data field is cleared"));
                            }
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, "No metadata found - data field remains unaltered"));
                        }
                        continue;
                    }

                    string metadataValue = metadata[this.metadataFieldName];
                    if (dataLabelToUpdate == Constant.DatabaseColumn.DateTime)
                    {
                        DateTimeOffset metadataDateTime;
                        if (DateTimeHandler.TryParseMetadataDateTaken(metadataValue, imageSetTimeZone, out metadataDateTime))
                        {
                            file.SetDateTimeOffset(metadataDateTime);
                            filesForDateTimeUpdate.Add(file);
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, metadataValue));
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, String.Format("'{0}' - data field remains unaltered - not a valid date/time.", metadataValue)));
                            continue;
                        }
                    }
                    else
                    {
                        filesToUpdate.Add(file.ID, metadataValue);
                        backgroundWorker.ReportProgress(0, new FeedbackMessage(file.FileName, metadataValue));
                    }

                    if (fileIndex % Constant.ThrottleValues.SleepForImageRenderInterval == 0)
                    {
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime); // put in a short delay every now and then, as otherwise the UI may not update
                    }
                }

                backgroundWorker.ReportProgress(0, new FeedbackMessage("Writing the data...", "Please wait..."));
                if (dateTimeUpdate)
                {
                    database.UpdateFiles(ImageRow.CreateDateTimeUpdate(filesForDateTimeUpdate));
                }
                else
                {
                    database.UpdateFiles(filesToUpdate);
                }
                backgroundWorker.ReportProgress(0, new FeedbackMessage("Done", "Done"));
            };
            backgroundWorker.ProgressChanged += (o, ea) =>
            {
                // get the message and add it to the data structure 
                FeedbackMessage message = (FeedbackMessage)ea.UserState;
                keyValueList.Add(new KeyValuePair<string, string>(message.FileName, message.Message));

                // scroll so the last object added is visible
                this.FeedbackGrid.ScrollIntoView(this.FeedbackGrid.Items[this.FeedbackGrid.Items.Count - 1]);
            };
            backgroundWorker.RunWorkerCompleted += (o, ea) =>
            {
                this.CancelDone.Content = "Done";
                this.CancelDone.IsEnabled = true;
            };
            backgroundWorker.RunWorkerAsync();
        }

        // Ensures that the columns will have appropriate header names. Can't be set directly in code otherwise
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "Image Name";
            this.FeedbackGrid.Columns[1].Header = "The Metadata Value for " + this.metadataFieldName;
        }

        private void PopulateButton_Click(object sender, RoutedEventArgs e)
        {
            this.PopulateField();
        }

        private void CancelDoneButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = ((string)this.CancelDone.Content == "Cancel") ? false : true;
        }

        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.clearIfNoMetadata = (ClearIfNoMetadata.IsChecked == true) ? true : false;
        }

        private class FeedbackMessage
        {
            public string FileName { get; set; }
            public string Message { get; set; }

            public FeedbackMessage(string fileName, string message)
            {
                this.FileName = fileName;
                this.Message = message;
            }
        }
    }
}
