using MetadataExtractor;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Timelapse.Database;
using Timelapse.Util;
using Directory = MetadataExtractor.Directory;

namespace Timelapse.Dialog
{
    /// <summary>
    /// This dialog displays a list of available data fields (currently the note, date and time fields), and 
    /// a list of metadata found in the current image. It asks the user to select one from each.
    /// The user can then populate the selected data field with the corresponding metadata value from that image for all images.
    /// </summary>
    public partial class PopulateFieldWithMetadata : Window
    {
        private bool clearIfNoMetadata;
        private ImageDatabase database;
        private string dataFieldLabel;
        private bool dataFieldSelected;
        private Dictionary<string, string> dataLabelByLabel;
        private string filePath;
        private string metadataFieldName;
        private bool metadataFieldSelected;

        public PopulateFieldWithMetadata(ImageDatabase database, string filePath, Window owner)
        {
            this.InitializeComponent();
            this.Owner = owner;

            this.clearIfNoMetadata = false;
            this.database = database;
            this.dataFieldLabel = String.Empty;
            this.dataFieldSelected = false;
            this.dataLabelByLabel = new Dictionary<string, string>();
            this.filePath = filePath;
            this.metadataFieldName = String.Empty;
            this.metadataFieldSelected = false;
        }

        // After the interface is loaded, 
        // - Load the Exif data into the data grid
        // - Load the names of the note controls into the listbox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            Utilities.SetDefaultDialogPosition(this);
            Utilities.TryFitWindowInWorkingArea(this);

            this.lblImageName.Content = Path.GetFileName(this.filePath);
            this.dataGrid.ItemsSource = Utilities.LoadMetadata(this.filePath);

            foreach (ControlRow control in this.database.TemplateTable)
            {
                if (control.Type == Constants.DatabaseColumn.DateTime ||
                    control.Type == Constants.Control.Note)
                {
                    this.dataLabelByLabel.Add(control.Label, control.DataLabel);
                    this.DataFields.Items.Add(control.Label);
                }
            }
        }

        // Label the column headers
        private void Datagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.dataGrid.Columns[0].Header = "Metadata Name";
            this.dataGrid.Columns[1].Header = "Example Value";
            this.dataGrid.SortByFirstColumnAscending();
        }

        // The user has selected a row. Get the metadata from that row, and make it the selected metadata.
        private void Datagrid_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        {
            IList<DataGridCellInfo> selectedcells = e.AddedCells;

            // Make sure there are actually some selected cells
            if (selectedcells == null || selectedcells.Count == 0)
            {
                return;
            }

            // We should only have a single selected cell, so just grab the first one
            DataGridCellInfo di = selectedcells[0];

            // the selected item is the entire row, where the format returned is [MetadataName , MetadataValue] 
            // Parse out the metadata name
            String[] s = di.Item.ToString().Split(',');  // Get the "[Metadataname" portion before the ','
            this.metadataFieldName = s[0].Substring(1);              // Remove the leading '['
            this.Metadata.Content = this.metadataFieldName;

            // Note that metadata name may still has spaces in it. We will have to strip it out and check it to make sure its an acceptable data label
            this.metadataFieldSelected = true;
            this.PopulateButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        }

        // Listbox Callback indicating the user has selected a data field. 
        private void NoteFieldsListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.DataFields.SelectedItem != null)
            {
                this.DataField.Content = this.DataFields.SelectedItem as string;
                this.dataFieldLabel = this.DataFields.SelectedItem as string;
                this.dataFieldSelected = true;
            }

            this.PopulateButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        }

        // Populate the database with the metadata for the selected note field
        private void Populate()
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<KeyValuePair<string, string>> keyValueList = new ObservableCollection<KeyValuePair<string, string>>();
            this.FeedbackGrid.ItemsSource = keyValueList;

            // Update the UI to show the feedback datagrid, 
            this.PopulatingMessage.Text = "Populating the data field '" + this.dataFieldLabel + "' from each file's '" + this.metadataFieldName + "' metadata ";
            this.PopulateButton.Visibility = Visibility.Collapsed; // Hide the populate button, as we are now in the act of populating things
            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.DataFields.Visibility = Visibility.Collapsed;
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;

            BackgroundWorker backgroundWorker = new BackgroundWorker() { WorkerReportsProgress = true };
            backgroundWorker.DoWork += (ow, ea) =>
            {
                // this runs on the background thread; its written as an anonymous delegate
                // We need to invoke this to allow updates on the UI
                this.Dispatcher.Invoke(new Action(() =>
                {
                }));

                // For each row in the database, get the image filename and try to extract the chosen metatag value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.
                // This tuple list will hold the id, key and value that we will want to update in the database
                string dataLabelToUpdate = this.dataLabelByLabel[this.dataFieldLabel];
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                TimeZoneInfo imageSetTimeZone = this.database.ImageSet.GetTimeZone();
                for (int imageIndex = 0; imageIndex < database.CurrentlySelectedImageCount; ++imageIndex)
                {
                    ImageRow image = database.ImageDataTable[imageIndex];
                    Dictionary<string, string> metadata = Utilities.LoadMetadata(image.GetImagePath(database.FolderPath));
                    if (metadata.ContainsKey(this.metadataFieldName) == false)
                    {
                        if (this.clearIfNoMetadata)
                        {
                            // Clear the data field if there is no metadata...
                            if (dataLabelToUpdate == Constants.DatabaseColumn.DateTime)
                            {
                                image.SetDateAndTimeFromFileInfo(this.database.FolderPath, imageSetTimeZone);
                                imagesToUpdate.Add(image.GetDateTimeColumnTuples());
                                backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, "No metadata found - date/time reread from file"));
                            }
                            else
                            {
                                List<ColumnTuple> clearField = new List<ColumnTuple>() { new ColumnTuple(this.dataLabelByLabel[this.dataFieldLabel], String.Empty) };
                                imagesToUpdate.Add(new ColumnTuplesWithWhere(clearField, image.ID));
                                backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, "No metadata found - data field is cleared"));
                            }
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, "No metadata found - data field remains unaltered"));
                        }
                        continue;
                    }

                    string metadataValue = metadata[this.metadataFieldName];
                    ColumnTuplesWithWhere imageUpdate;
                    if (dataLabelToUpdate == Constants.DatabaseColumn.DateTime)
                    {
                        DateTimeOffset metadataDateTime;
                        if (DateTimeHandler.TryParseMetadataDateTaken(metadataValue, imageSetTimeZone, out metadataDateTime))
                        {
                            image.SetDateAndTime(metadataDateTime);
                            imageUpdate = image.GetDateTimeColumnTuples();
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, metadataValue));
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, String.Format("'{0}' - data field remains unaltered - not a valid date/time.", metadataValue)));
                            continue;
                        }
                    }
                    else
                    {
                        imageUpdate = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, metadataValue) }, image.ID);
                        backgroundWorker.ReportProgress(0, new FeedbackMessage(image.FileName, metadataValue));
                    }
                    imagesToUpdate.Add(imageUpdate);

                    if (imageIndex % Constants.ThrottleValues.SleepForImageRenderInterval == 0)
                    {
                        Thread.Sleep(Constants.ThrottleValues.RenderingBackoffTime); // Put in a short delay every now and then, as otherwise the UI may not update.
                    }
                }

                backgroundWorker.ReportProgress(0, new FeedbackMessage("Writing the data...", "Please wait..."));
                database.UpdateImages(imagesToUpdate);
                backgroundWorker.ReportProgress(0, new FeedbackMessage("Done", "Done"));
            };
            backgroundWorker.ProgressChanged += (o, ea) =>
            {
                // Get the message and add it to the data structure 
                FeedbackMessage message = (FeedbackMessage)ea.UserState;
                keyValueList.Add(new KeyValuePair<string, string>(message.FileName, message.Message));

                // Scrolls so the last object added is visible
                this.FeedbackGrid.ScrollIntoView(FeedbackGrid.Items[FeedbackGrid.Items.Count - 1]);
            };
            backgroundWorker.RunWorkerCompleted += (o, ea) =>
            {
                btnCancel.Content = "Done"; // Change the Cancel button to Done, but inactivate it as we don't want the operation to be cancellable (due to worries about database corruption)
                btnCancel.IsEnabled = true;
            };
            backgroundWorker.RunWorkerAsync();
        }

        // Ensures that the columns will have appropriate header names. Can't be set directly in code otherwise
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "Image Name";
            this.FeedbackGrid.Columns[1].Header = "The Metadata Value for " + this.metadataFieldName;
        }

        private void PopulateButton_Click(object sender, RoutedEventArgs e)
        {
            this.Populate();
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = ((string)btnCancel.Content == "Cancel") ? false : true;
        }

        // This checkbox sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.clearIfNoMetadata = (ClearIfNoMetadata.IsChecked == true) ? true : false;
        }

        // Classes that tracks our progress as we load the images
        // These are needed to make the background worker update correctly.
        private class FeedbackMessage
        {
            public string FileName { get; set; }
            public string Message { get; set; }

            public FeedbackMessage(string fileName, string message)
            {
                this.FileName = fileName;
                this.Message = message;
            }
        }
    }
}
