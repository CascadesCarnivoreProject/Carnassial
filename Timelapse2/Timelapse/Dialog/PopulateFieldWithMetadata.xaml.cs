using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Timelapse.Database;
using Timelapse.Images;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// This dialog displays a list of available data fields (currently the note, date and time fields), and 
    /// a list of metadata found in the current image. It asks the user to select one from each.
    /// The user can then populate the selected data field with the corresponding metadata value from that image for all images.
    /// </summary>
    public partial class PopulateFieldWithMetadata : Window, IDisposable
    {
        private Dictionary<string, string> dataLabelFromLabel = new Dictionary<string, string>();  // DataLabel, Label
        private bool disposed;
        private ExifToolWrapper exifTool;
        private string metadataName = String.Empty;
        private string dataFieldLabel = String.Empty;

        private ImageDatabase database;
        private string imageFilePath;
        private bool isSelectedDataField = false;
        private bool isSelectedMetadata = false;
        private bool isClearIfNoMetadata = false;

        public PopulateFieldWithMetadata(ImageDatabase database, string imageFilePath, Window owner)
        {
            this.InitializeComponent();

            this.imageFilePath = imageFilePath;
            this.database = database;
            this.disposed = false;
            this.Owner = owner;
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (this.disposed)
            {
                return;
            }

            if (disposing)
            {
                if (this.exifTool != null)
                {
                    this.exifTool.Dispose();
                }
            }

            this.disposed = true;
        }

        // After the interface is loaded, 
        // - Load the Exif data into the data grid
        // - Load the names of the note controls into the listbox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            Utilities.SetDefaultDialogPosition(this);
            Utilities.TryFitWindowInWorkingArea(this);

            this.lblImageName.Content = Path.GetFileName(this.imageFilePath);
            this.LoadExif();
            this.LoadDataFieldLabels();
        }

        #region Loading EXIF into the data grid
        // Use the ExifToolWrapper to load all the metadata
        // Note that this requires the exiftool(-k).exe to be available in the executables folder 
        private void LoadExif()
        {
            this.exifTool = new ExifToolWrapper();
            this.exifTool.Start();

            Dictionary<string, string> exifData = this.exifTool.FetchExifFrom(this.imageFilePath);
            this.dg.ItemsSource = exifData; // Bind the dictionary to the data grid. For some reason, I couldn't do this in  xaml
        }

        #endregion

        #region Configuring the data grid appearance
        // Label the column headers
        private void Datagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            dg.Columns[0].Header = "Metadata Name";
            dg.Columns[1].Header = "Example Value";
            this.SortDataGrid();
        }

        // Sort the DataGrid by the metadata names (similar to clicking the first column header)
        public void SortDataGrid()
        {
            var column = this.dg.Columns[0];
            ListSortDirection sortDirection = ListSortDirection.Ascending;

            // Clear current sort descriptions
            dg.Items.SortDescriptions.Clear();

            // Add the new sort description
            dg.Items.SortDescriptions.Add(new SortDescription(column.SortMemberPath, sortDirection));

            // Apply sort
            foreach (var col in dg.Columns)
            {
                col.SortDirection = null;
            }
            column.SortDirection = sortDirection;

            // Refresh items to display sort
            dg.Items.Refresh();
        }
        #endregion

        #region Datagrid callbacks
        // The user has selected a row. Get the metadata from that row, and make it the selected metadata.
        private void Datagrid_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        {
            IList<DataGridCellInfo> selectedcells = e.AddedCells;

            // Make sure there are actually some selected cells
            if (selectedcells == null || selectedcells.Count == 0)
            {
                return;
            }

            // We should only have a single selected cell, so just grab the first one
            DataGridCellInfo di = selectedcells[0];

            // the selected item is the entire row, where the format returned is [MetadataName , MetadataValue] 
            // Parse out the metadata name
            String[] s = di.Item.ToString().Split(',');  // Get the "[Metadataname" portion before the ','
            this.metadataName = s[0].Substring(1);              // Remove the leading '['
            this.Metadata.Content = this.metadataName;

            // Note that metadata name may still has spaces in it. We will have to strip it out and check it to make sure its an acceptable data label
            this.isSelectedMetadata = true;
            this.PopulateButton.IsEnabled = this.isSelectedDataField && this.isSelectedMetadata;
        }
        #endregion

        #region Notefields callbacks
        public void LoadDataFieldLabels()
        {
            foreach (ControlRow control in this.database.TemplateTable)
            {
                if (control.Type == Constants.Control.Note ||
                    control.Type == Constants.DatabaseColumn.DateTime)
                {
                    this.dataLabelFromLabel.Add(control.Label, control.DataLabel);
                    // this.NoteID = control.ID; // Not sure why this line wasn't deleted, but and old note says to use this ID to pass between controls and data
                    this.DataFields.Items.Add(control.Label);
                }
            }
        }

        // Listbox Callback indicating the user has selected a data field. 
        private void NoteFieldsListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.DataFields.SelectedItem != null)
            {
                this.DataField.Content = this.DataFields.SelectedItem as string;
                this.dataFieldLabel = this.DataFields.SelectedItem as string;
                this.isSelectedDataField = true;
            }
            // If both the 
            this.PopulateButton.IsEnabled = this.isSelectedDataField && this.isSelectedMetadata;
        }
        #endregion

        // Populate the database with the metadata for the selected note field
        private void Populate()
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<KeyValuePair<string, string>> keyValueList = new ObservableCollection<KeyValuePair<string, string>>();
            this.FeedbackGrid.ItemsSource = keyValueList;

            // Update the UI to show the feedback datagrid, 
            this.PopulatingMessage.Text = "Populating the data field '" + this.dataFieldLabel + "' from each file's '" + this.metadataName + "' metadata ";
            this.PopulateButton.Visibility = Visibility.Collapsed; // Hide the populate button, as we are now in the act of populating things
            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.DataFields.Visibility = Visibility.Collapsed;
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;

            BackgroundWorker backgroundWorker = new BackgroundWorker() { WorkerReportsProgress = true };
            backgroundWorker.DoWork += (ow, ea) =>
            {
                // this runs on the background thread; its written as an anonymous delegate
                // We need to invoke this to allow updates on the UI
                this.Dispatcher.Invoke(new Action(() =>
                {
                }));

                // For each row in the database, get the image filename and try to extract the chosen metatag value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.
                // This tuple list will hold the id, key and value that we will want to update in the database
                string dataLabelToUpdate = this.dataLabelFromLabel[this.dataFieldLabel];
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                TimeZoneInfo imageSetTimeZone = this.database.ImageSet.GetTimeZone();
                for (int image = 0; image < database.CurrentlySelectedImageCount; image++)
                {
                    ImageRow imageProperties = database.ImageDataTable[image];
                    string[] tags = { this.metadataName };
                    Dictionary<string, string> exifData = this.exifTool.FetchExifFrom(imageProperties.GetImagePath(database.FolderPath), tags);
                    if (exifData.Count <= 0)
                    {
                        if (this.isClearIfNoMetadata)
                        {
                            // Clear the data field if there is no metadata...
                            ColumnTuplesWithWhere imageClear = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(this.dataLabelFromLabel[this.dataFieldLabel], String.Empty) },
                                                                                         imageProperties.ID);
                            imagesToUpdate.Add(imageClear);
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(imageProperties.FileName, "No metadata found - data field is cleared"));
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(imageProperties.FileName, "No metadata found - data field remains unaltered"));
                        }
                        continue;
                    }

                    string metadataValue = exifData[this.metadataName];
                    ColumnTuplesWithWhere imageUpdate;
                    if (dataLabelToUpdate == Constants.DatabaseColumn.DateTime)
                    {
                        DateTimeOffset metadataDateTime;
                        if (DateTimeHandler.TryParseMetadataDateTaken(metadataValue, imageSetTimeZone, out metadataDateTime))
                        {
                            imageProperties.SetDateAndTime(metadataDateTime);
                            imageUpdate = imageProperties.GetDateTimeColumnTuples();
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(imageProperties.FileName, metadataValue));
                        }
                        else
                        {
                            backgroundWorker.ReportProgress(0, new FeedbackMessage(imageProperties.FileName, String.Format("'{0}' - data field remains unaltered - not a valid date/time.", metadataValue)));
                            continue;
                        }
                    }
                    else
                    {
                        imageUpdate = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, metadataValue) }, imageProperties.ID);
                        backgroundWorker.ReportProgress(0, new FeedbackMessage(imageProperties.FileName, metadataValue));
                    }
                    imagesToUpdate.Add(imageUpdate);

                    if (image % Constants.ThrottleValues.SleepForImageRenderInterval == 0)
                    {
                        Thread.Sleep(Constants.ThrottleValues.RenderingBackoffTime); // Put in a short delay every now and then, as otherwise the UI may not update.
                    }
                }

                backgroundWorker.ReportProgress(0, new FeedbackMessage("Writing the data...", "Please wait..."));
                database.UpdateImages(imagesToUpdate);
                backgroundWorker.ReportProgress(0, new FeedbackMessage("Done", "Done"));
            };
            backgroundWorker.ProgressChanged += (o, ea) =>
            {
                // Get the message and add it to the data structure 
                FeedbackMessage message = (FeedbackMessage)ea.UserState;
                keyValueList.Add(new KeyValuePair<string, string>(message.FileName, message.Message));

                // Scrolls so the last object added is visible
                this.FeedbackGrid.ScrollIntoView(FeedbackGrid.Items[FeedbackGrid.Items.Count - 1]);
            };
            backgroundWorker.RunWorkerCompleted += (o, ea) =>
            {
                btnCancel.Content = "Done"; // Change the Cancel button to Done, but inactivate it as we don't want the operation to be cancellable (due to worries about database corruption)
                btnCancel.IsEnabled = true;
            };
            backgroundWorker.RunWorkerAsync();
        }

        #region Datagrid appearance
        // Ensures that the columns will have appropriate header names. Can't be set directly in code otherwise
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "Image Name";
            this.FeedbackGrid.Columns[1].Header = "The Metadata Value for " + this.metadataName;
        }
        #endregion

        #region UI Button Callbacks
        private void PopulateButton_Click(object sender, RoutedEventArgs e)
        {
            this.Populate();
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = ((string)btnCancel.Content == "Cancel") ? false : true;
        }

        // This checkbox sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.isClearIfNoMetadata = (ClearIfNoMetadata.IsChecked == true) ? true : false;
        }
        #endregion

        // Classes that tracks our progress as we load the images
        // These are needed to make the background worker update correctly.
        private class FeedbackMessage
        {
            public string FileName { get; set; }
            public string Message { get; set; }

            public FeedbackMessage(string fileName, string message)
            {
                this.FileName = fileName;
                this.Message = message;
            }
        }
    }
}
