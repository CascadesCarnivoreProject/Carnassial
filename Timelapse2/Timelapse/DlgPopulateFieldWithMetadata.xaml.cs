using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using BBCSharp;
using System.ComponentModel;
using System.Data;
using System.Collections.ObjectModel;

namespace Timelapse
{
    /// <summary>
    /// Interaction logic for DlgPopulateFieldWithMetadata.xaml
    /// This dialog displays a list of available data fields (currently the note, date and time fields), and 
    /// a list of metadata found in the current image. It asks the user to select one from each.
    /// The user can then populate the selected data field with the corresponding metadata value from that image for all images.
    /// </summary>

    public partial class DlgPopulateFieldWithMetadata : Window
    {
        private Dictionary<string, string> dictMetaDataLookup { get; set; }
        private Dictionary<string, string> dictNoteFieldLookup = new Dictionary<string, string>();  // DataLabel, Label
        private ExifToolWrapper extw;
        private string MetaDataName = "";
        private string NoteLabel = "";
        private string NoteDataLabel = "";

        private string fileName;
        private DBData dbData;
        private string folderPath;
        private bool isSelectedDataField = false;
        private bool isSelectedMetaData = false;
        private bool isClearIfNoMetaData = false;

        public DlgPopulateFieldWithMetadata(DBData db_data, string file_name, string folder_path)
        {
            this.fileName = file_name;
            this.folderPath = folder_path;
            this.dbData = db_data;
            InitializeComponent();
        }

        // After the interface is loaded, 
        // - Load the Exif data into the data grid
        // - Load the names of the note controls into the listbox
        // TODO: ERROR CHECK CORRUPTED, ETC.. that the exiftool exists, AND THAT WE CAN OPEN THE FILE AND GET THE EXIF AND 
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Make sure the title bar of the dialog box is on the screen. For small screens it may default to being off the screen
            if (this.Left < 10 || this.Top < 10)
            {
                this.Left = this.Owner.Left + (this.Owner.Width - this.ActualWidth) / 2; //Center it horizontally
                this.Top = this.Owner.Top + 20; // Offset it from the windows'top by 20 pixels downwards
            }

            lblImageName.Content = this.fileName;
            LoadExif();
            LoadDataFieldLabels();
        }

        #region Loading EXIF into the data grid
        // Use the ExifToolWrapper to load all the metadata
        // Note that this requires the exiftool(-k).exe to be available in the executables folder 
        internal void LoadExif()
        {
            extw = new ExifToolWrapper();
            extw.Start();

            dictMetaDataLookup = extw.FetchExifFrom(System.IO.Path.Combine (folderPath, fileName));
            this.dg.ItemsSource = dictMetaDataLookup; // Bind the dictionary to the data grid. For some reason, I couldn't do this in  xaml
        }

        #endregion

        #region Configuring the data grid appearance
        // Label the column headers
        private void dg_AutoGeneratedColumns(object sender, EventArgs e)
        {
            dg.Columns[0].Header = "MetaData Name";
            dg.Columns[1].Header = "Example Value";
            SortDataGrid();
        }

        // Sort the DataGrid by the metadata names (similar to clicking the first column header)
        public void SortDataGrid()
        {
            var column = this.dg.Columns[0];
            ListSortDirection sortDirection = ListSortDirection.Ascending;

            // Clear current sort descriptions
            dg.Items.SortDescriptions.Clear();

            // Add the new sort description
            dg.Items.SortDescriptions.Add(new SortDescription(column.SortMemberPath, sortDirection));

            // Apply sort
            foreach (var col in dg.Columns)
            {
                col.SortDirection = null;
            }
            column.SortDirection = sortDirection;

            // Refresh items to display sort
            dg.Items.Refresh();
        }
        #endregion

        #region Datagrid callbacks
        // The user has selected a row. Get the metadata from that row, and make it the selected metadata.
        private void dg_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        {
            IList<DataGridCellInfo> selectedcells = e.AddedCells;

            // Make sure there are actually some selected cells
            if (null == selectedcells || selectedcells.Count == 0) return;

            // We should only have a single selected cell, so just grab the first one
            DataGridCellInfo di = selectedcells[0];

            // the selected item is the entire row, where the format returned is [MetadataName , MetadataValue] 
            // Parse out the metadata name
            String[] s = di.Item.ToString().Split(',');  // Get the "[Metadataname" portion before the ','
            this.MetaDataName = s[0].Substring(1);              // Remove the leading '['
            this.lblMetaData.Content = this.MetaDataName;

            // Note that metadata name may still has spaces in it. We will have to strip it out and check it to make sure its an acceptable data label
            isSelectedMetaData = true;
            btnPopulate.IsEnabled = (isSelectedDataField && isSelectedMetaData);
        }
        #endregion

        #region Notefields callbacks
        public void LoadDataFieldLabels()
        {
            DataTable sortedTemplateTable = dbData.TemplateGetSortedByControls();
            for (int i = 0; i < sortedTemplateTable.Rows.Count; i++)
            {
                // Get the values for each control
                DataRow row = sortedTemplateTable.Rows[i];
                string type = row[Constants.TYPE].ToString();
                
                if (type == Constants.NOTE || type == Constants.DATE || type == Constants.TIME )
                {
                    string datalabel = (string)row[Constants.DATALABEL];
                    string label = (string)row[Constants.LABEL];
                    this.dictNoteFieldLookup.Add (label, datalabel );
                    // this.NoteID = Convert.ToInt32(row[Constants.ID].ToString()); // TODO Need to use this ID to pass between controls and data
                    this.lboxNoteFields.Items.Add(label);
                }
            }
        }

        // Listbox Callback indicating the user has selected a data field. 
        private void lboxNoteFields_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lboxNoteFields.SelectedItem != null)
            { 
                this.lblNoteField.Content = lboxNoteFields.SelectedItem as String;
                this.NoteLabel = lboxNoteFields.SelectedItem as String;
                isSelectedDataField = true;
            }
            // If both the 
            btnPopulate.IsEnabled = (isSelectedDataField && isSelectedMetaData);
        }
        #endregion

        #region Populate the database with the metadata for that note field
        //  Populate the database with the metadata for that note field
        private void Populate()
        {
            Dictionary<string, string> dictTemp;
           
            // This tuple list will hold the id, key and value that we will want to update in the database
            List<Tuple<int, string, string>> list_to_update_db = new List<Tuple<int, string, string>>();

            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<MyKeyValue> MyKeyValueList = new ObservableCollection<MyKeyValue>();
            this.dgFeedback.ItemsSource = MyKeyValueList;

            string fname;
            string[] tags = {this.MetaDataName};

            // Update the UI to show the feedback datagrid, 
            this.tbPopulatingMessage.Text = "Populating the data field '" + this.NoteDataLabel + "' from each image's '" + this.MetaDataName + "' metadata ";
            btnPopulate.Visibility = Visibility.Collapsed; // Hide the populate button, as we are now in the act of populating things
            cbClearIfNoMetada.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.lboxNoteFields.Visibility = Visibility.Collapsed;
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;

            var bgw = new BackgroundWorker() { WorkerReportsProgress = true };
            bgw.DoWork += (ow, ea) =>
            {   // this runs on the background thread; its written as an anonymous delegate
                // We need to invoke this to allow updates on the UI
                this.Dispatcher.Invoke(new Action(() =>
                {
                }));

                // For each row in the database, get the image filename and try to extract the chosen metatag value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetaData (set via the checkbox)
                // Report progress as needed.
                for (int i = 0; i < dbData.dataTable.Rows.Count; i++)
                {
                    fname = dbData.dataTable.Rows[i][Constants.FILE].ToString();
                    int id = Int32.Parse(dbData.dataTable.Rows[i][Constants.ID].ToString());
                    dictTemp = extw.FetchExifFrom(System.IO.Path.Combine(this.folderPath, fname), tags);
                    if (dictTemp.Count <= 0)
                    {
                        if (this.isClearIfNoMetaData)
                        {
                            list_to_update_db.Add(new Tuple<int, string, string>(id, dictNoteFieldLookup [this.NoteLabel], "")); // Clear the data field if there is no metadata...
                            bgw.ReportProgress(0, new FeedbackMessage(fname, "No metadata found - data field is cleared"));
                        }
                        else
                        {
                            bgw.ReportProgress(0, new FeedbackMessage(fname, "No metadata found - data field remains unaltered"));
                        }
                        continue;
                    }
                    string value = dictTemp[this.MetaDataName];
                    bgw.ReportProgress(0, new FeedbackMessage(fname, value));
                    if (i % 250 == 0) System.Threading.Thread.Sleep(25); // Put in a short delay every now and then, as otherwise the UI may not update.
                    list_to_update_db.Add(new Tuple<int, string, string>(id, dictNoteFieldLookup[this.NoteLabel], value));
                }

                bgw.ReportProgress(0, new FeedbackMessage("Writing the data...", "Please wait..."));
                dbData.RowsUpdateByRowIdKeyVaue(list_to_update_db);
                bgw.ReportProgress(0, new FeedbackMessage("Done", "Done"));
            };
            bgw.ProgressChanged += (o, ea) =>
            {   
                // Get the message and add it to the data structure 
                FeedbackMessage message = (FeedbackMessage)ea.UserState;
                MyKeyValueList.Add(new MyKeyValue { Key = message.Filename, Value = message.MetadataValue });

                // Scrolls so the last object added is visible
                this.dgFeedback.ScrollIntoView(dgFeedback.Items[dgFeedback.Items.Count - 1]);  
            };
            bgw.RunWorkerCompleted += (o, ea) =>
            {
                btnCancel.Content = "Done"; // Change the Cancel button to Done, but inactivate it as we don't want the operation to be cancellable (due to worries about database corruption)
                btnCancel.IsEnabled = true;
            };
            bgw.RunWorkerAsync();
        }
        #endregion

        #region Datagrid appearance
        // Ensures that the columns will have appropriate header names. Can't be set directly in code otherwise
        private void dgFeedback_AutoGeneratedColumns(object sender, EventArgs e)
        {
            dgFeedback.Columns[0].Header = "Image Name";
            dgFeedback.Columns[1].Header = "The Metadata Value for " + this.MetaDataName;
        }
        #endregion

        #region UI Button Callbacks
        private void btnPoplulate_Click(object sender, RoutedEventArgs e)
        {
            Populate();
        }

        private void btnCancel_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = ((string) btnCancel.Content == "Cancel") ? false : true;
        }
       

        // This checkbox sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void cbClearIfNoMetada_Checked(object sender, RoutedEventArgs e)
        {
            this.isClearIfNoMetaData = (cbClearIfNoMetada.IsChecked == true) ? true : false;
        }
        #endregion

        #region Feedback Helper Classes
        // Classes that tracks our progress as we load the images
        // These are needed to make the background worker update correctly.
        private class FeedbackMessage
        {
            public string Filename { get; set; }
            public string MetadataValue { get; set; }
            public FeedbackMessage(string fname, string value)
            {
                Filename = fname;
                MetadataValue = value;
            }
        }
        private class MyKeyValue
        {
            public string Key { get; set; }
            public string Value { get; set; }
        }
        #endregion 
    }
}
